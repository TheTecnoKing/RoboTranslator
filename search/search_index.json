{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RoboTranslator Software del layer di traduzione per la comunicazione tra microcontrollori e server web. Parte del progetto di Robotica \"Costruiamo un robot\" [\u21aa] . Todo Work in progress! Panoramica RoboTranslator \u00e8 un software scritto in Python che si occupa di fare da ponte tra dei robot comandati da microcontrollori (in questo caso, degli Arduino) e un server di controllo. Spiegando meglio, esso scambia dati con i microcontrollori tramite una connessione seriale via Bluetooth, li elabora per facilitarne le interazioni, e infine li rende disponibili tramite una API in REST oppure WebSocket. Crediti e licenze Software sviluppato da Kristian Ceribashi , 3A-AU, e da Andrea Gennaioli , 3B-IN, ITIS \"E. Mattei\" - Urbino, 2021-2022. Software sviluppato per il progetto PON di robotica \"Costruiamo un robot\". Il progetto in s\u00e8 non ha una licenza, ma, se decidi di usarlo da qualche parte, una menzione sarebbe gradita! Librerie Open Source utilizzate per lo sviluppo del progetto: PyBluez , licenza GPLv2 FastAPI , licenza MIT Uvicorn , licenza BSD 3-Clause \"New\" or \"Revised\" License Simple Terminal Menu , licenza MIT","title":"Pagina iniziale"},{"location":"#robotranslator","text":"Software del layer di traduzione per la comunicazione tra microcontrollori e server web. Parte del progetto di Robotica \"Costruiamo un robot\" [\u21aa] . Todo Work in progress!","title":"RoboTranslator"},{"location":"#panoramica","text":"RoboTranslator \u00e8 un software scritto in Python che si occupa di fare da ponte tra dei robot comandati da microcontrollori (in questo caso, degli Arduino) e un server di controllo. Spiegando meglio, esso scambia dati con i microcontrollori tramite una connessione seriale via Bluetooth, li elabora per facilitarne le interazioni, e infine li rende disponibili tramite una API in REST oppure WebSocket.","title":"Panoramica"},{"location":"#crediti-e-licenze","text":"Software sviluppato da Kristian Ceribashi , 3A-AU, e da Andrea Gennaioli , 3B-IN, ITIS \"E. Mattei\" - Urbino, 2021-2022. Software sviluppato per il progetto PON di robotica \"Costruiamo un robot\". Il progetto in s\u00e8 non ha una licenza, ma, se decidi di usarlo da qualche parte, una menzione sarebbe gradita! Librerie Open Source utilizzate per lo sviluppo del progetto: PyBluez , licenza GPLv2 FastAPI , licenza MIT Uvicorn , licenza BSD 3-Clause \"New\" or \"Revised\" License Simple Terminal Menu , licenza MIT","title":"Crediti e licenze"},{"location":"api/","text":"API Todo Work in progress!","title":"API"},{"location":"api/#api","text":"Todo Work in progress!","title":"API"},{"location":"config/","text":"Configurazione RoboTranslator pu\u00f2 essere configurato andando a modificare il file config.json incluso nella repository oppure generato automaticamente al primo avvio. Struttura di config.json { \"firstTime\" : false , \"devices\" : [ { \"name\" : \"HC-05\" , \"address\" : \"2C:54:91:88:C9:E3\" , \"sensors\" : { \"x\" : [ 0 , 1024 ], \"c\" : [ \"-\" , 0 , 1 ], ... }, \"actuators\" : { \"y\" : [ 0 , 2048 ], \"b\" : [ \"-\" , 0 , 1 ], ... } } ], \"scanDuration\" : 5 , \"refreshInterval\" : 0.05 , \"timeout\" : 1 } schema forse coming soon Parametri firstTime : bool Indica al programma se esso \u00e8 mai stato eseguito. Se \u00e8 la prima volta che viene avviato, effettuer\u00e0, come prima cosa, una fase di ricerca e salvataggio dei dispositivi Bluetooth, altrimenti avvier\u00e0 la comunicazione con i dispositivi gi\u00e0 salvati nella sezione devices . devices : list Questa sezione contiene tutti i dati riguardanti i dispositivi configurati. Ogni elemento di questa lista \u00e8 un dict composto da 4 chiavi: name : str Nome del dispositivo address : str Indirizzo MAC del dispositivo sensors : dict Insieme dei sensori presenti sul dispositivo. \u00c8 composto a sua volta da: key : str Carattere indicante il tipo di sensore. Non deve obbligatoriamente fare parte del database dei sensori ed attuatori, ma \u00e8 altamente consigliato che ne faccia. Questo permette un'identificazione pi\u00f9 facile del dato, sia lato debugging, sia lato API. value : list Range di valori che possono essere ricevuti. Tipicamente questa lista \u00e8 formata da due elementi: uno di partenza ed uno di fine, entrambi inclusi. \"sensors\" : { \"x\" : [ 0 , 1024 ], \"c\" : [ \"-\" , 0 , 1 , ... ], ... } Se nel primo indice \u00e8 presente un trattino ( \"-\" ), allora i valori non verranno interpretati come valori di inizio e fine, bens\u00ec come valori a se stanti. Di conseguenza, solo in questo caso \u00e8 possibile avere pi\u00f9 di due valori all'interno della lista, ed essi saranno gli unici valori ad essere accettati nella ricezione dati. \"sensors\" : { \"x\" : [ 0 , 1024 ], \"c\" : [ \"-\" , 0 , 1 , ... ], ... } actuators : dict Insieme dei sensori presenti sul dispositivo. La sua struttura e funzionamento \u00e8 identica a quella di sensors , quindi rivolgersi a quella sezione per la documentazione. Unica differenza \u00e8 che, mentre sensors si occupa di descrivere i dati che si possono ricevere dai dispositivi, actuators indica quali dati possono essere inviati dal Server ai Client. scanDuration : int Imposta la durata di scansione dei dispositivi (in secondi) in caso di primo avvio (forzato e non). refreshInterval : float Imposta l'intervallo di aggiornamento dei dati (in secondi), ossia il tempo tra l'invio di una richiesta dati dal Server e un'altra (per maggiori informazioni, vedi Protocollo ). timeout : float Imposta il tempo massimo di timeout ricezione dati (in secondi). Per maggiori informazioni, vedi Protocollo .","title":"Configurazione"},{"location":"config/#configurazione","text":"RoboTranslator pu\u00f2 essere configurato andando a modificare il file config.json incluso nella repository oppure generato automaticamente al primo avvio.","title":"Configurazione"},{"location":"config/#struttura-di-configjson","text":"{ \"firstTime\" : false , \"devices\" : [ { \"name\" : \"HC-05\" , \"address\" : \"2C:54:91:88:C9:E3\" , \"sensors\" : { \"x\" : [ 0 , 1024 ], \"c\" : [ \"-\" , 0 , 1 ], ... }, \"actuators\" : { \"y\" : [ 0 , 2048 ], \"b\" : [ \"-\" , 0 , 1 ], ... } } ], \"scanDuration\" : 5 , \"refreshInterval\" : 0.05 , \"timeout\" : 1 } schema forse coming soon","title":"Struttura di config.json"},{"location":"config/#parametri","text":"","title":"Parametri"},{"location":"config/#firsttime-bool","text":"Indica al programma se esso \u00e8 mai stato eseguito. Se \u00e8 la prima volta che viene avviato, effettuer\u00e0, come prima cosa, una fase di ricerca e salvataggio dei dispositivi Bluetooth, altrimenti avvier\u00e0 la comunicazione con i dispositivi gi\u00e0 salvati nella sezione devices .","title":"firstTime: bool"},{"location":"config/#devices-list","text":"Questa sezione contiene tutti i dati riguardanti i dispositivi configurati. Ogni elemento di questa lista \u00e8 un dict composto da 4 chiavi: name : str Nome del dispositivo address : str Indirizzo MAC del dispositivo sensors : dict Insieme dei sensori presenti sul dispositivo. \u00c8 composto a sua volta da: key : str Carattere indicante il tipo di sensore. Non deve obbligatoriamente fare parte del database dei sensori ed attuatori, ma \u00e8 altamente consigliato che ne faccia. Questo permette un'identificazione pi\u00f9 facile del dato, sia lato debugging, sia lato API. value : list Range di valori che possono essere ricevuti. Tipicamente questa lista \u00e8 formata da due elementi: uno di partenza ed uno di fine, entrambi inclusi. \"sensors\" : { \"x\" : [ 0 , 1024 ], \"c\" : [ \"-\" , 0 , 1 , ... ], ... } Se nel primo indice \u00e8 presente un trattino ( \"-\" ), allora i valori non verranno interpretati come valori di inizio e fine, bens\u00ec come valori a se stanti. Di conseguenza, solo in questo caso \u00e8 possibile avere pi\u00f9 di due valori all'interno della lista, ed essi saranno gli unici valori ad essere accettati nella ricezione dati. \"sensors\" : { \"x\" : [ 0 , 1024 ], \"c\" : [ \"-\" , 0 , 1 , ... ], ... } actuators : dict Insieme dei sensori presenti sul dispositivo. La sua struttura e funzionamento \u00e8 identica a quella di sensors , quindi rivolgersi a quella sezione per la documentazione. Unica differenza \u00e8 che, mentre sensors si occupa di descrivere i dati che si possono ricevere dai dispositivi, actuators indica quali dati possono essere inviati dal Server ai Client.","title":"devices: list"},{"location":"config/#scanduration-int","text":"Imposta la durata di scansione dei dispositivi (in secondi) in caso di primo avvio (forzato e non).","title":"scanDuration: int"},{"location":"config/#refreshinterval-float","text":"Imposta l'intervallo di aggiornamento dei dati (in secondi), ossia il tempo tra l'invio di una richiesta dati dal Server e un'altra (per maggiori informazioni, vedi Protocollo ).","title":"refreshInterval: float"},{"location":"config/#timeout-float","text":"Imposta il tempo massimo di timeout ricezione dati (in secondi). Per maggiori informazioni, vedi Protocollo .","title":"timeout: float"},{"location":"install/","text":"Installazione Todo Rifare la documentazione per l'installazione! Note L'intero progetto \u00e8 stato sviluppato su un Raspberry Pi 4 con Ubuntu 20.04.4 aarch64 , e testato anche su un Raspberry Pi 3B+ con Debian 11 aarch64 . Di conseguenza, anche le istruzioni d'installazione sono state scritte basandosi su questi dispositivi. Se si vuole installare il software su un'altra configurazione, le procedure potrebbero essere differenti. In tal caso, una ricerca su Google o nella documentazione delle varie dipendenze non fa mai male! Installare Python 3.8 o versione superiore (dovrebbe essere preinstallato nelle ultime versioni LTS di Ubuntu e Debian), libbluetooth-dev , bluetooth e bluez : sudo apt-get install python3 libbluetooth-dev bluetooth bluez Modificare il servizio bluetoothd in modo che si avvii in modalit\u00e0 compatibilit\u00e0 aggiungendo \"-C\" al parametro di avvio (fonte qui ): Attention Il file del servizio viene sovrascritto ad ogni suo aggiornamento! Andare alla fonte per maggiori informazioni. sudo nano /etc/systemd/system/dbus-org.bluez.service [...] ExecStart=/usr/lib/bluetooth/bluetoothd -C 3. Aggiungere il profilo seriale a SDP: sudo sdptool add SP 4. Rendere il dispositivo ricercabile (fonte qui ): Attention Questo comando non lo render\u00e0 ricercabile per sempre ! Per poter eseguire il comando ad ogni avvio consiglio di dare un'occhiata alla fonte. sudo hciconfig hci0 piscan 5. Cambiare i permessi d'accesso al server Bluetooth del dispositivo (fonte qui ): Attention Anche questo comando \u00e8 temporaneo... L'andazzo \u00e8 sempre lo stesso: vedi fonte per maggiori info. sudo chmod o+rw /var/run/sdp 6. Clonare la repository: git clone https://github.com/TheTecnoKing/RoboTranslator.git Todo (TODO) Installare le varie dipendenze per l'esecuzione del software: python3 -m pip install -r requirements.txt Et voil\u00e0! Lavoro finito!","title":"Installazione"},{"location":"install/#installazione","text":"Todo Rifare la documentazione per l'installazione! Note L'intero progetto \u00e8 stato sviluppato su un Raspberry Pi 4 con Ubuntu 20.04.4 aarch64 , e testato anche su un Raspberry Pi 3B+ con Debian 11 aarch64 . Di conseguenza, anche le istruzioni d'installazione sono state scritte basandosi su questi dispositivi. Se si vuole installare il software su un'altra configurazione, le procedure potrebbero essere differenti. In tal caso, una ricerca su Google o nella documentazione delle varie dipendenze non fa mai male! Installare Python 3.8 o versione superiore (dovrebbe essere preinstallato nelle ultime versioni LTS di Ubuntu e Debian), libbluetooth-dev , bluetooth e bluez : sudo apt-get install python3 libbluetooth-dev bluetooth bluez Modificare il servizio bluetoothd in modo che si avvii in modalit\u00e0 compatibilit\u00e0 aggiungendo \"-C\" al parametro di avvio (fonte qui ): Attention Il file del servizio viene sovrascritto ad ogni suo aggiornamento! Andare alla fonte per maggiori informazioni. sudo nano /etc/systemd/system/dbus-org.bluez.service [...] ExecStart=/usr/lib/bluetooth/bluetoothd -C 3. Aggiungere il profilo seriale a SDP: sudo sdptool add SP 4. Rendere il dispositivo ricercabile (fonte qui ): Attention Questo comando non lo render\u00e0 ricercabile per sempre ! Per poter eseguire il comando ad ogni avvio consiglio di dare un'occhiata alla fonte. sudo hciconfig hci0 piscan 5. Cambiare i permessi d'accesso al server Bluetooth del dispositivo (fonte qui ): Attention Anche questo comando \u00e8 temporaneo... L'andazzo \u00e8 sempre lo stesso: vedi fonte per maggiori info. sudo chmod o+rw /var/run/sdp 6. Clonare la repository: git clone https://github.com/TheTecnoKing/RoboTranslator.git Todo (TODO) Installare le varie dipendenze per l'esecuzione del software: python3 -m pip install -r requirements.txt Et voil\u00e0! Lavoro finito!","title":"Installazione"},{"location":"protocol/","text":"Protocollo Todo separa comunicazione e protocollo in due file separati, ma cmq nella stessa cartella descrivi la struttura del messaggio Tutti i dati sono contenuti in messaggi da 4 byte ciascuno. Struttura del messaggio Comunicazione standard sequenceDiagram autonumber Server->>Client: '@' (richiesta dati) activate Server Client->>Server: Dati sensori Note left of Server: Durata: `refreshInterval` + tempo di risposta Server->>Client: Comando deactivate Server Client->>Server: Dati sensori Immagine PNG disponibile qui Il Server effettua una richiesta dati al Client tramite l'invio di un singolo char : '@' . Il Client risponde con i dati di tutti i suoi sensori, ognuno di essi seguente la struttura del messaggio descritta sopra . Il Server invia un comando al Client con la struttura definita nella sezione \" Struttura del messaggio \". Il client effettua l'azione programmata nel suo codice e restituisce al Server i dati di tutti i suoi sensori. Comunicazione per errori lato client sequenceDiagram autonumber Server->>Client: '@'/Comando loop MAX x3 Client--xServer: Timeout/dati invalidi activate Server Note left of Server: Max. durata: `timeout` Server->>Client: Ripete '@'/Comando deactivate Server end alt FINE LOOP Note over Client: Guasto! end Client->>Server: Dati sensori Immagine PNG disponibile qui Il Server invia un comando generico al Client. Il Client riceve il messaggio e restituisce i dati di tutti i suoi sensori, per\u00f2, dal lato server: Avviene un timeout (i dati ci hanno messo troppo ad arrivare, o non sono proprio partiti) I dati ricevuti sono invalidi (fuori dal range impostato in config.json ) Il Server riconosce l'errore e rimanda l'ultimo messaggio inviato in precedenza . Ci\u00f2 pu\u00f2 avvenire per massimo 3 volte , alla fine delle quali il Client viene contrassegnato come guasto. Il Client invia nuovamente i dati di tutti i suoi sensori correttamente. Comunicazione per errori lato server sequenceDiagram autonumber loop MAX x3 Server--xClient: '@'/Comando (problemi d'invio) activate Server Server-->>Server: In attesa... Note left of Server: Durata: `timeout` Server->>Client: Ripete '@'/Comando per timeout deactivate Server end alt FINE LOOP Note over Server: Guasto! end Client->>Server: Dati sensori Immagine PNG disponibile qui Il Server invia un comando generico al Client, ma il messaggio non riesce ad arrivare integro al Client a causa di errori o mancato invio. Il Client, non avendo ricevuto un messaggio valido, non risponde al Server. Quest'ultimo si mette in attesa di una risposta dal Client, che non arriver\u00e0 mai. Passa un certo tempo di timeout ( config.json ) nel quale il Server non riceve i dati, ed esso capisce che \u00e8 qualcosa \u00e8 andato storto. Di conseguenza, il Server rimanda l'ultimo messaggio inviato in precedenza . Questa procedura pu\u00f2 essere ripetuta massimo 3 volte , dopo la quale il Server segnala un guasto alla comunicazione. Il client riceve un messaggio valido ed invia i dati di tutti i suoi sensori. Riepilogo sequenceDiagram rect rgba(76, 174, 79, 0.5) Server->>Client: '@'/Comando activate Server Client->>Server: Dati sensori end Note left of Server: Durata: `refreshInterval` + tempo di risposta rect rgba(172, 174, 76, 0.2) alt ERRORE CLIENT Server->>Client: '@'/Comando deactivate Server loop MAX x3 Client--xServer: Timeout/dati invalidi activate Server Note left of Server: Max. durata: `timeout` Server->>Client: Ripete '@'/Comando deactivate Server end rect rgba(174, 76, 76, 0.5) alt FINE LOOP Note over Client: Guasto! end end Client->>Server: Dati sensori end end rect rgba(172, 174, 76, 0.2) alt ERRORE SERVER loop MAX x3 Server--xClient: '@'/Comando (problemi d'invio) activate Server Server-->>Server: In attesa... Note left of Server: Durata: `timeout` Server->>Client: Ripete '@'/Comando per timeout deactivate Server end rect rgba(174, 76, 76, 0.5) alt FINE LOOP Note over Server: Guasto! end end Client->>Server: Dati sensori end end Immagine PNG disponibile qui","title":"Protocollo"},{"location":"protocol/#protocollo","text":"Todo separa comunicazione e protocollo in due file separati, ma cmq nella stessa cartella descrivi la struttura del messaggio Tutti i dati sono contenuti in messaggi da 4 byte ciascuno.","title":"Protocollo"},{"location":"protocol/#struttura-del-messaggio","text":"","title":"Struttura del messaggio"},{"location":"protocol/#comunicazione-standard","text":"sequenceDiagram autonumber Server->>Client: '@' (richiesta dati) activate Server Client->>Server: Dati sensori Note left of Server: Durata: `refreshInterval` + tempo di risposta Server->>Client: Comando deactivate Server Client->>Server: Dati sensori Immagine PNG disponibile qui Il Server effettua una richiesta dati al Client tramite l'invio di un singolo char : '@' . Il Client risponde con i dati di tutti i suoi sensori, ognuno di essi seguente la struttura del messaggio descritta sopra . Il Server invia un comando al Client con la struttura definita nella sezione \" Struttura del messaggio \". Il client effettua l'azione programmata nel suo codice e restituisce al Server i dati di tutti i suoi sensori.","title":"Comunicazione standard"},{"location":"protocol/#comunicazione-per-errori-lato-client","text":"sequenceDiagram autonumber Server->>Client: '@'/Comando loop MAX x3 Client--xServer: Timeout/dati invalidi activate Server Note left of Server: Max. durata: `timeout` Server->>Client: Ripete '@'/Comando deactivate Server end alt FINE LOOP Note over Client: Guasto! end Client->>Server: Dati sensori Immagine PNG disponibile qui Il Server invia un comando generico al Client. Il Client riceve il messaggio e restituisce i dati di tutti i suoi sensori, per\u00f2, dal lato server: Avviene un timeout (i dati ci hanno messo troppo ad arrivare, o non sono proprio partiti) I dati ricevuti sono invalidi (fuori dal range impostato in config.json ) Il Server riconosce l'errore e rimanda l'ultimo messaggio inviato in precedenza . Ci\u00f2 pu\u00f2 avvenire per massimo 3 volte , alla fine delle quali il Client viene contrassegnato come guasto. Il Client invia nuovamente i dati di tutti i suoi sensori correttamente.","title":"Comunicazione per errori lato client"},{"location":"protocol/#comunicazione-per-errori-lato-server","text":"sequenceDiagram autonumber loop MAX x3 Server--xClient: '@'/Comando (problemi d'invio) activate Server Server-->>Server: In attesa... Note left of Server: Durata: `timeout` Server->>Client: Ripete '@'/Comando per timeout deactivate Server end alt FINE LOOP Note over Server: Guasto! end Client->>Server: Dati sensori Immagine PNG disponibile qui Il Server invia un comando generico al Client, ma il messaggio non riesce ad arrivare integro al Client a causa di errori o mancato invio. Il Client, non avendo ricevuto un messaggio valido, non risponde al Server. Quest'ultimo si mette in attesa di una risposta dal Client, che non arriver\u00e0 mai. Passa un certo tempo di timeout ( config.json ) nel quale il Server non riceve i dati, ed esso capisce che \u00e8 qualcosa \u00e8 andato storto. Di conseguenza, il Server rimanda l'ultimo messaggio inviato in precedenza . Questa procedura pu\u00f2 essere ripetuta massimo 3 volte , dopo la quale il Server segnala un guasto alla comunicazione. Il client riceve un messaggio valido ed invia i dati di tutti i suoi sensori.","title":"Comunicazione per errori lato server"},{"location":"protocol/#riepilogo","text":"sequenceDiagram rect rgba(76, 174, 79, 0.5) Server->>Client: '@'/Comando activate Server Client->>Server: Dati sensori end Note left of Server: Durata: `refreshInterval` + tempo di risposta rect rgba(172, 174, 76, 0.2) alt ERRORE CLIENT Server->>Client: '@'/Comando deactivate Server loop MAX x3 Client--xServer: Timeout/dati invalidi activate Server Note left of Server: Max. durata: `timeout` Server->>Client: Ripete '@'/Comando deactivate Server end rect rgba(174, 76, 76, 0.5) alt FINE LOOP Note over Client: Guasto! end end Client->>Server: Dati sensori end end rect rgba(172, 174, 76, 0.2) alt ERRORE SERVER loop MAX x3 Server--xClient: '@'/Comando (problemi d'invio) activate Server Server-->>Server: In attesa... Note left of Server: Durata: `timeout` Server->>Client: Ripete '@'/Comando per timeout deactivate Server end rect rgba(174, 76, 76, 0.5) alt FINE LOOP Note over Server: Guasto! end end Client->>Server: Dati sensori end end Immagine PNG disponibile qui","title":"Riepilogo"},{"location":"todo/","text":"To-do Todo Work in progress! Lorem ipsum dolor sit amet, consectetur adipiscing elit Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque","title":"To-do"},{"location":"todo/#to-do","text":"Todo Work in progress! Lorem ipsum dolor sit amet, consectetur adipiscing elit Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque","title":"To-do"},{"location":"usage/","text":"Utilizzo del software Todo Work in progress!","title":"Utilizzo"},{"location":"usage/#utilizzo-del-software","text":"Todo Work in progress!","title":"Utilizzo del software"}]}